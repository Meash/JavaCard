//generating key pair
import javacard.security.KeyPair;

KeyPair keypair = new KeyPair(KeyPair.ALG_EC_F2M, (short)512);
keypair.genKeyPair();
PublicKey publickey = keypair.getPublic();
PrivateKey privatekey = keypair.getPrivate();

//generate secret key
import javacard.security.KeyAgreement;
byte[] otherPublicKeyBytes = ...get public key bytes;
KeyAgreement ka = KeyAgreement.getInstance(KeyAgreement.ALG_EC_SVDP_DH, false);
ka.init(privatekey);
byte[] key = ...put key here;
ka.generateSecret(otherPublicKeyBytes, (short)0, (short)otherPublicKeyBytes.length, key, (short)0);

//encrypting message (from SecureRMIDemoSecurity)

import javacard.security.AESKey;
import javacard.security.KeyBuilder;
import javacard.security.CryptoException;
import javacardx.crypto.Cipher;

   private AESKey aeskey = (AESKey)KeyBuilder.buildKey(KeyBuilder.TYPE_AES_TRANSIENT_DESELECT, KeyBuilder.LENGTH_AES_128, false);
   private byte[] keyBytes = key; // 16 bytes for a 128-bit AES cipher
   aeskey.setKey(keyBytes, (short)0);
   private byte[] ivBytes = ... // 16 bytes (one block) initialization vector... random
   private Cipher cipher; // AES cipher in CBC mode with no padding
   
   public boolean processDataIn(APDU apdu)
   {  if (selectingApplet())
      {  // APDU is for selecting applet so clear security settings
         resetSecuritySettings();
         return false; // allow other Services to preprocess if needed
      }
      else if (!apdu.isSecureMessagingCLA())
      {  // APDU CLA byte does not indicate secure messaging
         // clear the appropriate command security properties
         commandProperties &=
            ~(SecurityService.PROPERTY_INPUT_CONFIDENTIALITY |
            SecurityService.PROPERTY_OUTPUT_CONFIDENTIALITY);
         return false; // allow other Services to preprocess if needed
      }
      else
      {  // set the appropriate command security properties
         commandProperties |=
            (SecurityService.PROPERTY_INPUT_CONFIDENTIALITY |
            SecurityService.PROPERTY_OUTPUT_CONFIDENTIALITY);
         // get the incoming APDU buffer
         byte[] buffer = apdu.getBuffer();
         byte lc = buffer[ISO7816.OFFSET_LC]; // padded length
         byte le = buffer[(short)(ISO7816.OFFSET_LC+lc+1)];
         // decrypt the data field in the command APDU
         if (lc % BLOCK_SIZE != 0)
            CryptoException.throwIt(CryptoException.ILLEGAL_VALUE);         
         if (!key.isInitialized())
            key.setKey(keyBytes, (short)0); // (re)initialize key
         cipher.init(key, Cipher.MODE_DECRYPT, ivBytes, (short)0,
            (short)ivBytes.length);
         byte[] deciphertext = getTransientArray(lc);
         cipher.doFinal(buffer, ISO7816.OFFSET_CDATA, lc, deciphertext,
            (short)0);
         byte numPadding = deciphertext[(short)(lc-1)];
         byte unpaddedLength = (byte)(lc - numPadding);
         Util.arrayCopyNonAtomic(deciphertext, (short)0,
            buffer, ISO7816.OFFSET_CDATA, unpaddedLength);
         buffer[ISO7816.OFFSET_LC] = unpaddedLength;
         buffer[(short)(ISO7816.OFFSET_LC+unpaddedLength+1)] = le;
         // reset the CLA security bits
         buffer[ISO7816.OFFSET_CLA] &= ~CLA_SECURITY_BITS_MASK;
         return true; // don't allow any other preprocessing
      }
   }
   
   // overridden method of BasicService that performs encryption
   // returns true if no more postprocessing should be performed
   // by any other Service that has been added to handles the APDU
   public boolean processDataOut(APDU apdu)
   {  if (selectingApplet())
         return false; //allow other Services to postprocess if needed
      else
      {  // get outgoing APDU buffer (CLA,INS,SW1,SW2,Le,data field)
         byte[] buffer = apdu.getBuffer();
         // encrypt the data field in response APDU
         if (!key.isInitialized())
            key.setKey(keyBytes, (short)0); // (re)initialize key
         cipher.init(key, Cipher.MODE_ENCRYPT, ivBytes, (short)0,
            (short)ivBytes.length);
         byte unpaddedLength = (byte)(buffer[OFFSET_OUT_LA] & 0xFF);
         // pad the buffer segment to have blocks of length BLOCK_SIZE
         // bytes as per PKCS#5 padding scheme where the padding bytes
         // always each give the number of padded bytes
         short numBlocks=(short)((short)(unpaddedLength+BLOCK_SIZE)
            / BLOCK_SIZE);
         short paddedLength = (short)(numBlocks*BLOCK_SIZE);
         byte[] padded = getTransientArray(paddedLength);
         Util.arrayCopyNonAtomic(buffer, OFFSET_OUT_RDATA, padded,
            (short)0, unpaddedLength);
         byte numPadding = (byte)(paddedLength - unpaddedLength);
         for (short i=unpaddedLength; i<paddedLength; i++)
            padded[i] = numPadding;
         if ((short)(OFFSET_OUT_RDATA-1+paddedLength) > buffer.length)
            // outgoing buffer can not accommodate the padding
            CryptoException.throwIt(CryptoException.ILLEGAL_VALUE);
         cipher.doFinal(padded, (short)0, (short)paddedLength, buffer,
            OFFSET_OUT_RDATA);
         buffer[OFFSET_OUT_LA] = (byte)paddedLength;
         return true; // don't allow any other postprocessing
      }
   }
   
   // adding hash code
   import java.security.MessageDigest;
   
   MessageDigest digest = MessageDigest.getInstance(MessageDigest.ALG_SHA, false);
   byte[] message = ...//get message to be sent;
   byte[] hashcode = ...//allocate space for hashcode;
   digest.doFinal(message, (short)0, (short)message.length, hashcode, (short)0);